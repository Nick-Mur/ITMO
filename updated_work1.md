## Разбор задач

### Задача 1: Определение свойств бинарного отношения и построение графа отношения

**Условие:**

Пусть aRb, если существует целое число k такое, что a - b = 3k. Определить свойства этого отношения (рефлексивность, симметричность, транзитивность) и построить граф отношения на множестве A = {1, 2, 3, 4, 5, 6}.

---

**Решение:**

1. **Рефлексивность**

   **Определение:**
   
   Отношение R на множестве A называется **рефлексивным**, если для каждого элемента a из A выполняется aRa.

   **Проверка:**
   
   Для любого a из Z:
   
   a - a = 0 = 3 * 0
   
   Поскольку 0 делится на 3, отношение aRa выполняется для всех a из A.

   **Вывод:**
   
   Отношение R является рефлексивным.

2. **Симметричность**

   **Определение:**
   
   Отношение R на множестве A называется **симметричным**, если для любых a и b из A из aRb следует bRa.

   **Проверка:**
   
   Пусть aRb, тогда существует целое число k такое, что:
   
   a - b = 3k
   
   Тогда:
   
   b - a = -3k = 3 * (-k)
   
   Поскольку -k также целое число, отношение bRa выполняется.

   **Вывод:**
   
   Отношение R является симметричным.

3. **Транзитивность**

   **Определение:**
   
   Отношение R на множестве A называется **транзитивным**, если для любых a, b и c из A из aRb и bRc следует aRc.

   **Проверка:**
   
   Пусть aRb и bRc, тогда существуют целые числа k1 и k2 такие, что:
   
   a - b = 3k1
   
   b - c = 3k2
   
   Сложим оба уравнения:
   
   (a - b) + (b - c) = a - c = 3(k1 + k2)
   
   Поскольку k1 + k2 также целое число, отношение aRc выполняется.

   **Вывод:**
   
   Отношение R является транзитивным.

4. **Заключение о свойствах отношения**
   
   Поскольку отношение R является рефлексивным, симметричным и транзитивным, оно является **отношением эквивалентности** на множестве A.

5. **Построение графа отношения**
   
   Множество A = {1, 2, 3, 4, 5, 6} разбивается на классы эквивалентности по модулю 3:
   
   - Класс [0]: {3, 6}
   - Класс [1]: {1, 4}
   - Класс [2]: {2, 5}
   
   **Граф отношения** будет состоять из трех компонент, где элементы внутри каждого класса связаны между собой:
   
   - **Класс [0]:**
     3 --- 6
   
   - **Класс [1]:**
     1 --- 4
   
   - **Класс [2]:**
     2 --- 5
   
   **Визуализация графа:**
   
   ```
   1 --- 4
   
   2 --- 5
   
   3 --- 6
   ```

---

### Задача 2: Нахождение множества X = (A ∪ B) ∩ D^c

**Условие:**

Даны множества:
- A = {7, 2, 3}
- B = {1, 2, 5, 6}
- C = {2, 6, 8}
- D = {7, 5, ..., 83}

Найти множество:
X = (A объединить B) пересечь с дополнением множества D.

---

**Решение:**

1. **Вычислим объединение множеств A ∪ B:**
   
   A ∪ B = {1, 2, 3, 5, 6, 7}

2. **Определим дополнение множества D относительно универсума:**
   
   Предположим, что универсумом является множество всех целых чисел от 1 до 83. Тогда:
   
   D^c = {1, 2, 3, 4, 6, 8, ..., 82} \ {5, 7, ..., 83}

3. **Найдем пересечение X = (A ∪ B) ∩ D^c:**
   
   X = {1, 2, 3, 5, 6, 7} ∩ D^c = {1, 2, 3, 6}
   
   (Предполагая, что 5 и 7 принадлежат D)

---

**Ответ:**

X = {1, 2, 3, 6}

---

### Задача 3: Построение таблицы истинности, СДНФ, СКНФ и полинома Жегалкина для функции

**Условие:**

Дана функция:
f(X, Y, Z) = X → (Y или Z) ↑ ¬X

где:
- → — импликация
- ↑ — операция Штриха Шеффера (NAND)
- ¬ — отрицание

Требуется:
1. Построить таблицу истинности функции f.
2. Построить СДНФ (совершенную дизъюнктивную нормальную форму).
3. Построить СКНФ (совершенную конъюнктивную нормальную форму).
4. Построить полином Жегалкина.

---

**Решение:**

1. **Построение таблицы истинности**
   
   Рассмотрим все возможные комбинации значений переменных X, Y и Z:

   | X | Y | Z | Y или Z | ¬X | (Y или Z) ↑ ¬X | X → ((Y или Z) ↑ ¬X) | f(X, Y, Z) |
   |---|---|---|---------|----|-----------------|-----------------------|------------|
   | 0 | 0 | 0 |    0    | 1  |        1        |           1           |     1      |
   | 0 | 0 | 1 |    1    | 1  |        0        |           1           |     1      |
   | 0 | 1 | 0 |    1    | 1  |        0        |           1           |     1      |
   | 0 | 1 | 1 |    1    | 1  |        0        |           1           |     1      |
   | 1 | 0 | 0 |    0    | 0  |        1        |           1           |     1      |
   | 1 | 0 | 1 |    1    | 0  |        0        |           1           |     1      |
   | 1 | 1 | 0 |    1    | 0  |        0        |           1           |     1      |
   | 1 | 1 | 1 |    1    | 0  |        0        |           1           |     1      |

   **Таблица истинности:**

   | X | Y | Z | f(X, Y, Z) |
   |---|---|---|------------|
   | 0 | 0 | 0 |     1      |
   | 0 | 0 | 1 |     1      |
   | 0 | 1 | 0 |     1      |
   | 0 | 1 | 1 |     1      |
   | 1 | 0 | 0 |     1      |
   | 1 | 0 | 1 |     1      |
   | 1 | 1 | 0 |     1      |
   | 1 | 1 | 1 |     1      |

2. **Построение СДНФ (Совершенной дизъюнктивной нормальной формы)**
   
   Из таблицы истинности видно, что функция f(X, Y, Z) равна 1 для всех комбинаций. Следовательно, СДНФ:
   
   f(X, Y, Z) = 1

3. **Построение СКНФ (Совершенной конъюнктивной нормальной формы)**
   
   Так как функция f(X, Y, Z) всегда равна 1, СКНФ:
   
   f(X, Y, Z) = (X или ¬X) и (Y или ¬Y) и (Z или ¬Z)
   
   Упрощая, получаем:
   
   f(X, Y, Z) = 1

4. **Построение полинома Жегалкина**
   
   Поскольку f(X, Y, Z) = 1, полином Жегалкина:
   
   f(X, Y, Z) = 1

---

### Задача 4: Определение классов Поста для функции

**Условие:**

Для функции f(X, Y, Z) = X определить, к каким функциональным классам Поста она принадлежит.

---

**Решение:**

Классы Поста:
1. **T₀** (сохраняющие ноль): f(0, 0, 0) = 0
2. **T₁** (сохраняющие единицу): f(1, 1, 1) = 1
3. **S** (самодвойственные функции): f(X, Y, Z) = ¬f(¬X, ¬Y, ¬Z)
4. **M** (монотонные функции): функция не убывает при увеличении аргументов
5. **L** (линейные функции): функция линейна в алгебре Жегалкина

**Проверка принадлежности:**

1. **T₀:**
   
   f(0, y, z) = 0 независимо от y и z. Функция сохраняет ноль.

2. **T₁:**
   
   f(1, y, z) = 1 независимо от y и z. Функция сохраняет единицу.

3. **S (Самодвойственность):**
   
   Проверим:
   
   f(X, Y, Z) = X
   
   ¬f(¬X, ¬Y, ¬Z) = ¬(¬X) = X
   
   Следовательно:
   
   f(X, Y, Z) = ¬f(¬X, ¬Y, ¬Z)
   
   Это условие выполняется, значит функция является самодвойственной.

4. **M (Монотонность):**
   
   Функция f = X монотонна, так как при увеличении X значение функции не убывает.

5. **L (Линейность):**
   
   Полином Жегалкина для f = X линейный.

---

**Итог:**

Функция f(X, Y, Z) = X принадлежит классам **T₀**, **T₁**, **S**, **M**, **L**.

---

### Задача 5: Булевы функции двух переменных, принадлежащие T₀ и не принадлежащие S

**Условие:**

Найти все булевы функции от двух переменных, которые сохраняют ноль (принимают значение 0 на входе 0,0) и не являются самодвойственными.

---

**Решение:**

1. **Все булевы функции двух переменных (всего 16):**

   1. f = 0
   2. f = X
   3. f = Y
   4. f = X или Y
   5. f = X и Y
   6. f = X исключающее или Y (X ⊕ Y)
   7. f = X → Y
   8. f = Y → X
   9. f = ¬X
   10. f = ¬Y
   11. f = ¬X или Y
   12. f = X или ¬Y
   13. f = ¬X и Y
   14. f = X и ¬Y
   15. f = ¬X или ¬Y
   16. f = 1

2. **Выбираем функции, сохраняющие ноль (f(0, 0) = 0):**

   - f = 0
   - f = X
   - f = Y
   - f = X или Y
   - f = X и Y
   - f = X исключающее или Y
   - f = X и ¬Y
   - f = ¬X и Y

3. **Исключаем самодвойственные функции (не принадлежащие S):**

   Проверим самодвойственность для каждой функции из выбранных:

   - **f = 0:** Не является самодвойственной, так как ¬f(¬X, ¬Y) = 1 ≠ 0.
   - **f = X:** Не является самодвойственной.
   - **f = Y:** Не является самодвойственной.
   - **f = X или Y:** Не является самодвойственной.
   - **f = X и Y:** Не является самодвойственной.
   - **f = X исключающее или Y:** Не является самодвойственной.
   - **f = X и ¬Y:** Не является самодвойственной.
   - **f = ¬X и Y:** Не является самодвойственной.

---

**Итог:**

Булевы функции двух переменных, которые сохраняют ноль и не являются самодвойственными:

- f = X
- f = Y
- f = X или Y
- f = X и Y
- f = X исключающее или Y
- f = X и ¬Y
- f = ¬X и Y

---

### Задача 6: Доказательство функциональной полноты набора {→, ⊕, ¬} через классы Поста

**Условие:**

Доказать, что множество логических операций {→, ⊕, ¬} является функционально полным, используя классы Поста.

---

**Решение:**

Функциональная полнота означает, что с помощью операций из данного набора можно выразить все возможные булевы функции, то есть базовые операции: конъюнкцию (и), дизъюнкцию (или) и отрицание (¬).

Используя **классы Поста**, докажем функциональную полноту набора {→, ⊕, ¬}.

1. **Отрицание (¬)**
   
   Отрицание уже присутствует в наборе {→, ⊕, ¬}.

2. **Конъюнкция (и)**
   
   Выразим конъюнкцию через импликацию и отрицание:
   
   X и Y = ¬(X → ¬Y)
   
   **Пояснение:**
   
   - X → ¬Y = ¬X или ¬Y
   - Тогда ¬(X → ¬Y) = ¬(¬X или ¬Y) = X и Y

3. **Дизъюнкция (или)**
   
   Выразим дизъюнкцию через импликацию и отрицание:
   
   X или Y = ¬X → Y
   
   **Пояснение:**
   
   - ¬X → Y = X или Y

4. **Исключающее ИЛИ (⊕)**
   
   Операция ⊕ уже присутствует в наборе и может быть использована для построения других функций.

5. **Использование классов Поста для доказательства функциональной полноты**
   
   Согласно классам Поста, набор логических операций является функционально полным, если он не принадлежит ни одному из следующих неполных классов:
   
   - **T₀:** Функции, сохраняющие ноль.
   - **T₁:** Функции, сохраняющие единицу.
   - **S:** Самодвойственные функции.
   - **M:** Монотонные функции.
   - **L:** Линейные функции.
   
   Проверим, что набор {→, ⊕, ¬} не принадлежит ни одному из этих классов:
   
   - **Не принадлежит T₀:** Например, операция импликации (→) не сохраняет ноль, так как 0 → 1 = 1.
   - **Не принадлежит T₁:** Операция исключающего ИЛИ (⊕) не сохраняет единицу, например, 1 ⊕ 1 = 0.
   - **Не принадлежит S:** Набор включает операции, не являющиеся самодвойственными.
   - **Не принадлежит M:** Операция импликации не является монотонной.
   - **Не принадлежит L:** Набор содержит нелинейные операции, такие как ⊕

Поскольку набор {→, ⊕, ¬} не принадлежит ни одному из неполных классов Поста, он является функционально полным.

---

**Итог:**

Набор логических операций {→, ⊕, ¬} является функционально полным, так как с его помощью можно выразить все базовые булевы операции, и он не принадлежит никакому из неполных классов Поста.

---
