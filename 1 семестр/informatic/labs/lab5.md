# Шпаргалка по Git

## Основные команды Git

### Инициализация и конфигурация
- `git init`: Инициализировать новый репозиторий.
- `git clone <url>`: Клонировать существующий удалённый репозиторий.
- `git config --global user.name "Имя"` / `git config --global user.email "email@example.com"`: Настроить имя и email пользователя.

### Работа с индексом и коммитами
- `git status`: Показать состояние рабочего дерева и индекса.
- `git add <файл>` или `git add .`: Добавить файл(ы) в индекс для следующего коммита.
- `git commit -m "Сообщение"`: Создать коммит с индексированными изменениями.
- `git commit --amend`: Изменить последний коммит (например, поправить сообщение).

### Просмотр истории и изменений
- `git log` / `git log --oneline --graph`: Просмотр истории коммитов.
- `git diff`: Просмотр несохранённых изменений.
- `git diff --cached`: Просмотр изменений, добавленных в индекс.
- `git show <commit>`: Детали конкретного коммита.

### Ветки
- `git branch`: Список веток.
- `git branch <имя_ветки>`: Создать новую ветку.
- `git checkout <ветка>`: Переключиться на ветку.
- `git checkout -b <имя_ветки>`: Создать и сразу переключиться на новую ветку.
- `git merge <ветка>`: Слить изменения указанной ветки в текущую.
- `git rebase <ветка>`: Переписать историю коммитов, применяя коммиты текущей ветки поверх выбранной.

### Работа с удалёнными репозиториями
- `git remote add origin <url>`: Добавить удалённый репозиторий.
- `git push origin <ветка>`: Отправить изменения в удалённый репозиторий.
- `git fetch`: Получить данные об обновлениях с удалённого репозитория без их слияния.
- `git pull`: Получить и слить изменения с удалённого репозитория в текущую ветку.

---

## Конфликты: Возникновение и Решение

### Как возникают конфликты
- Конфликты возникают, когда Git не может автоматически слить изменения из-за противоречий в одном и том же участке кода.
- Частые причины: параллельное редактирование одной и той же строки файла, одновременный рефакторинг одного блока кода разными разработчиками.

### Как определить наличие конфликта
- При выполнении `git merge` или `git pull` слияние может остановиться, сообщая о конфликте.
- В файлах появляются специальные маркеры:
  ``` 
  <<<<<<< HEAD
  ...ваши изменения...
  =======
  ...изменения из сливаемой ветки...
  >>>>>>> имя/хеш ветки
  ```
  
### Как решать конфликты
1. Открыть конфликтующий файл, найти маркеры `<<<<<<<`, `=======`, `>>>>>>>`.
2. Вручную оставить нужный вариант изменений или объединить фрагменты.
3. Удалить маркеры конфликта после правок.
4. Добавить исправленный файл в индекс: `git add <файл>`.
5. Завершить процесс слияния коммитом: `git commit`.

### Рекомендации по предотвращению конфликтов
- Регулярно синхронизировать ветки (использовать `git pull` и актуальные изменения).
- Делить задачи на мелкие изменения.
- Держать ветки актуальными (rebase перед merge).
- Чётко распределять зоны ответственности по коду.

---

## Git Hooks

### Что такое Git Hooks?
- Скрипты, автоматически запускаемые Git при определённых событиях (коммит, пуш, слияние и т.д.).
- Располагаются в `.git/hooks/`.
- Предоставляют возможность автоматизировать проверки стиля кода, запуск тестов, валидацию сообщений коммитов и др.

### Основные типы хуков
- Клиентские хуки:
  - `pre-commit`: Перед созданием коммита (можно проверить качество кода).
  - `commit-msg`: Проверка или форматирование сообщения коммита.
  - `pre-push`: Проверка кода перед пушем.
- Серверные хуки:
  - `pre-receive`, `update`, `post-receive`: Запускаются на стороне сервера при получении коммитов.

### Настройка и использование
1. Перейти в `.git/hooks`.
2. Создать или изменить нужный хук (например, `pre-commit`).
3. Сделать хук исполняемым: `chmod +x pre-commit`.
4. Внутри хука написать скрипт (Bash, Python и т.д.), выполняющий необходимые проверки.
5. При последующем коммите хук будет выполнен автоматически.

---

## Git Flow

### Что такое Git Flow?
- Модель ветвления, упрощающая параллельную разработку, релизный цикл и выпуск хотфиксов.
- Предполагает использование нескольких типов веток с чётко определёнными задачами.

### Основные ветки
- **main (master)**: Ветка конечных релизов. Здесь всегда стабильный код.
- **develop**: Основная ветка разработки. Новый функционал интегрируется сюда.
- **feature/**: Ветки для разработки новых фич. Вытекают из `develop`, возвращаются в `develop`.
- **release/**: Ветки для подготовки релиза. Из `develop` → в `main` (и обратно в `develop`).
- **hotfix/**: Срочные исправления критических ошибок, ответвляются от `main` и возвращаются в `main` и `develop`.

### Основной цикл работы
1. Инициализация Git Flow:
   ```bash
   git flow init
   ```
   Принимаем или настраиваем структуру веток.
   
2. Разработка фичи:
   ```bash
   git flow feature start имя_фичи
   # разработка...
   git flow feature finish имя_фичи
   ```
   
3. Подготовка релиза:
   ```bash
   git flow release start vX.Y.Z
   # обновление версий, документации...
   git flow release finish vX.Y.Z
   ```
   
4. Горячие исправления (hotfix):
   ```bash
   git flow hotfix start hotfix-X.Y.Z
   # Исправление критической ошибки...
   git flow hotfix finish hotfix-X.Y.Z
   ```

### Преимущества Git Flow
- Чёткая структура и предсказуемые процессы.
- Упрощённое управление релизами и исправлениями.
- Лёгкое масштабирование на большие команды.

